<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sabine Reichsthaler Social Media Tool</title>
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <link rel="stylesheet" href="./style.css">

</head>
<body>

<div class="wrap">
  <section class="panel" id="controls">
    <h2>Format</h2>
    <div class="row">
      <label>Format</label>
      <select id="formatSelect">
        <option value="post" selected>Post (1080×1350)</option>
        <option value="story">Story (1080×1920)</option>
      </select>
    </div>

    <hr style="border:0;border-top:1px solid var(--border);margin:16px 0">

    <h2>Content</h2>
    <div class="row" style="justify-content:space-between;gap:10px;margin-bottom:14px">
      <span style="font-size:12px;color:#777">1 default field (white) + max 5 custom fields · 50 chars each</span>
      <button id="addField" class="btn">+ Add field</button>
    </div>
    <div id="fields" class="grid"></div>

    <hr style="border:0;border-top:1px solid var(--border);margin:16px 0">

    <h2>Actions</h2>
    <div class="row">
      <label>Randomize</label>
      <button id="shuffle" class="btn">Shuffle colors/sizes</button>
    </div>
    <div class="row">
      <label>Background</label>
      <input id="bgFile" type="file" accept="image/*" />
    </div>
    <div class="row">
      <label></label>
      <button id="whiteBg" class="btn">White BG</button>
      <button id="clearBg" class="btn">Clear</button>
    </div>
    <div class="row">
      <label>Export</label>
      <button id="download" class="btn primary">Download PNG</button>
    </div>
  </section>

  <section class="panel">
    <h2 id="canvasTitle">Canvas Post (1080×1350)</h2>
    <div id="canvas-holder"></div>
  </section>
</div>

<script>
// ====== Configuration ======
const FORMATS = {
  post: { w: 1080, h: 1350, name: 'Post (1080×1350)' },
  story: { w: 1080, h: 1920, name: 'Story (1080×1920)' }
};

let currentFormat = 'post';
let CANVAS_W = 1080;
let CANVAS_H = 1350;
let DISPLAY_SCALE = 1;
const CANVAS_PADDING = 16; // Added canvas padding

const PALETTE = ["#3AEA00","#FF6A00","#FFE500","#3B9DFF","#DF61BD"];

const SIZE_PRESETS = {
  S: { text: 64, padX: 30, padY: 20, r: 70 },
  M: { text: 100, padX: 45, padY: 30, r: 90 },
  L: { text: 144, padX: 30, padY: 36, r: 130 }
};

// Fonts
let fontTimes = null;

// State
let fields = [];
let bgImg = null;
let bgColor = 255;

// ====== p5 lifecycle ======
function preload(){
  fontTimes = loadFont('./TimesDotRom.otf', 
    () => console.log('Font loaded'), 
    () => {
      console.log('Font not found, using fallback');
      fontTimes = null;
    }
  );
}

function setup(){
  console.log('Setup starting...');
  
  // Calculate display scale
  const maxDisplayW = Math.min(window.innerWidth - 450, 800);
  const maxDisplayH = window.innerHeight - 200;
  const scaleW = maxDisplayW / CANVAS_W;
  const scaleH = maxDisplayH / CANVAS_H;
  DISPLAY_SCALE = Math.min(scaleW, scaleH, 1);
  
  console.log('Display scale:', DISPLAY_SCALE);
  
  // Create canvas
  const cnv = createCanvas(CANVAS_W * DISPLAY_SCALE, CANVAS_H * DISPLAY_SCALE);
  cnv.parent('canvas-holder');
  pixelDensity(2);
  
  // Set font
  if(fontTimes){
    textFont(fontTimes);
  } else {
    textFont('Georgia');
  }
  
  // Initialize fields
  fields = [{
    id: 'default',
    text: 'Your Text',
    size: 'L',
    color: '#FFFFFF',
    isDefault: true
  }];
  
  console.log('Fields initialized:', fields);
  
  // Setup UI
  setupUI();
  
  // Render fields UI
  refreshFieldRows();
  
  // Draw
  background(255);
  console.log('Drawing...');
  drawContent();
  
  console.log('Setup complete');
}

function draw(){
  // We don't use the default draw loop
}

function drawContent(){
  console.log('drawContent called, fields:', fields.length);
  
  // Clear and setup
  push();
  scale(DISPLAY_SCALE);
  
  // Calculate content area with padding
  const CONTENT_W = CANVAS_W - CANVAS_PADDING * 2;
  const CONTENT_H = CANVAS_H - CANVAS_PADDING * 2;
  
  // Background
  if(bgImg){
    const iw = bgImg.width;
    const ih = bgImg.height;
    const scl = Math.max(CANVAS_W/iw, CANVAS_H/ih);
    const dw = iw * scl;
    const dh = ih * scl;
    const dx = (CANVAS_W - dw) / 2;
    const dy = (CANVAS_H - dh) / 2;
    image(bgImg, dx, dy, dw, dh);
  } else {
    if(bgColor !== null){
      background(bgColor);
    } else {
      clear();
    }
  }
  
  // Measure all fields
  const measures = [];
  for(let i = 0; i < fields.length; i++){
    const f = fields[i];
    const preset = SIZE_PRESETS[f.size || 'M'];
    
    textFont(fontTimes || 'Georgia');
    textSize(preset.text);
    
    // Calculate width based on text content
    const txt = f.text || '';
    const textW = textWidth(txt);
    const fieldW = Math.min(textW + preset.padX * 2, CONTENT_W);
    
    // Wrap text if needed
    const maxW = CONTENT_W - preset.padX * 2;
    const lines = wrapText(txt, maxW);
    const h = lines.length * preset.text * 1.2 + preset.padY * 2;
    
    measures.push({
      field: f,
      lines: lines,
      w: fieldW,
      h: h,
      r: preset.r,
      tsize: preset.text,
      padX: preset.padX,
      padY: preset.padY
    });
  }
  
  console.log('Measures:', measures);
  
  // Arrange fields into rows (horizontal layout with wrapping)
  const rows = [];
  let currentRow = [];
  let currentRowWidth = 0;
  const GAP = 0; // Gap between fields (set to 0 for no spacing)
  
  for(let i = 0; i < measures.length; i++){
    const item = measures[i];
    
    // Check if adding this item would exceed content width
    if(currentRowWidth + item.w > CONTENT_W && currentRow.length > 0){
      // Start new row
      rows.push(currentRow);
      currentRow = [item];
      currentRowWidth = item.w;
    } else {
      // Add to current row
      currentRow.push(item);
      currentRowWidth += item.w + (currentRow.length > 1 ? GAP : 0);
    }
  }
  
  // Add last row
  if(currentRow.length > 0){
    rows.push(currentRow);
  }
  
  console.log('Rows:', rows);
  
  // Calculate total height of all rows
  let totalH = 0;
  for(let i = 0; i < rows.length; i++){
    let rowHeight = 0;
    for(let j = 0; j < rows[i].length; j++){
      rowHeight = Math.max(rowHeight, rows[i][j].h);
    }
    totalH += rowHeight;
  }
  
  console.log('Total height:', totalH, 'Canvas height:', CANVAS_H);
  
  // Draw rows (with padding offset)
  let y = CANVAS_PADDING + (CONTENT_H - totalH) / 2;
  
  for(let i = 0; i < rows.length; i++){
    const row = rows[i];
    
    // Calculate row width for centering
    let rowWidth = 0;
    let rowHeight = 0;
    for(let j = 0; j < row.length; j++){
      rowWidth += row[j].w;
      rowHeight = Math.max(rowHeight, row[j].h);
      if(j > 0) rowWidth += GAP;
    }
    
    // Start x position (centered with padding)
    let x = CANVAS_PADDING + (CONTENT_W - rowWidth) / 2;
    
    // Draw each field in the row
    for(let j = 0; j < row.length; j++){
      const item = row[j];
      
      console.log('Drawing field row', i, 'item', j, 'at x:', x, 'y:', y, 'width:', item.w, 'color:', item.field.color);
      
      // Draw background
      noStroke();
      fill(item.field.color || '#FFFFFF');
      rect(x, y, item.w, item.h, Math.min(item.r, item.h/2));
      
      // Add border for white fields
      if(item.field.color === '#FFFFFF' || item.field.isDefault){
       noStroke();
        noFill();
        rect(x, y, item.w, item.h, Math.min(item.r, item.h/2));
      }
      
      // Draw text
      noStroke();
      fill(0);
      textAlign(CENTER, CENTER);
      textFont(fontTimes || 'Georgia');
      textSize(item.tsize);
      
      const lineHeight = item.tsize * 0.96;
      const textBlockH = item.lines.length * lineHeight;
      const textY = y + (item.h - textBlockH) / 2 + lineHeight / 2 - item.tsize * 0.05;
      
      for(let k = 0; k < item.lines.length; k++){
        text(item.lines[k], x + item.w / 2, textY + k * lineHeight);
      }
      
      x += item.w + GAP;
    }
    
    y += rowHeight;
  }
  
  pop();
  console.log('Drawing complete');
}

function wrapText(txt, maxWidth){
  if(!txt) return [''];
  
  const words = txt.split(' ');
  const lines = [];
  let currentLine = '';
  
  for(let i = 0; i < words.length; i++){
    const testLine = currentLine + (currentLine ? ' ' : '') + words[i];
    const testWidth = textWidth(testLine);
    
    if(testWidth > maxWidth && currentLine !== ''){
      lines.push(currentLine);
      currentLine = words[i];
    } else {
      currentLine = testLine;
    }
  }
  
  if(currentLine) lines.push(currentLine);
  
  return lines.length > 0 ? lines : [''];
}

// ====== UI Functions ======
function randColor(){ 
  return PALETTE[Math.floor(Math.random() * PALETTE.length)]; 
}

function randSize(){ 
  return ['S','M'][Math.floor(Math.random() * 2)]; 
}

function addNewField(){
  const customCount = fields.filter(f => !f.isDefault).length;
  if(customCount >= 5) {
    alert('Maximum 5 custom fields allowed');
    return;
  }
  
  const obj = {
    id: Math.random().toString(36).slice(2),
    text: 'New Field',
    size: randSize(),
    color: randColor(),
    isDefault: false
  };
  
  fields.push(obj);
  refreshFieldRows();
  drawContent();
}

function removeField(id){
  fields = fields.filter(f => f.id !== id);
  refreshFieldRows();
  drawContent();
}

function updateField(id, prop, value){
  const field = fields.find(f => f.id === id);
  if(field){
    if(prop === 'text'){
      field[prop] = value.slice(0, 50);
    } else {
      field[prop] = value;
    }
    drawContent();
  }
}

function changeFormat(format){
  currentFormat = format;
  CANVAS_W = FORMATS[format].w;
  CANVAS_H = FORMATS[format].h;
  
  const maxDisplayW = Math.min(window.innerWidth - 450, 800);
  const maxDisplayH = window.innerHeight - 200;
  const scaleW = maxDisplayW / CANVAS_W;
  const scaleH = maxDisplayH / CANVAS_H;
  DISPLAY_SCALE = Math.min(scaleW, scaleH, 1);
  
  resizeCanvas(CANVAS_W * DISPLAY_SCALE, CANVAS_H * DISPLAY_SCALE);
  
  document.getElementById('canvasTitle').textContent = 'Canvas ' + FORMATS[format].name;
  
  drawContent();
}

function setupUI(){
  // Format selector
  document.getElementById('formatSelect').onchange = (e) => {
    changeFormat(e.target.value);
  };
  
  // Add field button
  document.getElementById('addField').onclick = addNewField;
  
  // Shuffle button
  document.getElementById('shuffle').onclick = () => {
    for(let i = 0; i < fields.length; i++){
      if(!fields[i].isDefault){
        fields[i].size = randSize();
        fields[i].color = randColor();
      }
    }
    refreshFieldRows();
    drawContent();
  };
  
  // Background upload
  document.getElementById('bgFile').onchange = (e) => {
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    const url = URL.createObjectURL(file);
    loadImage(url, (img) => {
      bgImg = img;
      bgColor = null;
      drawContent();
      URL.revokeObjectURL(url);
    });
  };
  
  // White/Clear background
  document.getElementById('whiteBg').onclick = () => {
    bgImg = null;
    bgColor = 255;
    drawContent();
  };
  
  document.getElementById('clearBg').onclick = () => {
    bgImg = null;
    bgColor = 255;
    drawContent();
  };
  
  // Download button
  document.getElementById('download').onclick = () => {
    const tempCanvas = createGraphics(CANVAS_W, CANVAS_H);
    tempCanvas.pixelDensity(2);
    tempCanvas.textFont(fontTimes || 'Georgia');
    
    // Calculate content area with padding
    const CONTENT_W = CANVAS_W - CANVAS_PADDING * 2;
    const CONTENT_H = CANVAS_H - CANVAS_PADDING * 2;
    
    // Background
    if(bgImg){
      const iw = bgImg.width;
      const ih = bgImg.height;
      const scl = Math.max(CANVAS_W/iw, CANVAS_H/ih);
      const dw = iw * scl;
      const dh = ih * scl;
      const dx = (CANVAS_W - dw) / 2;
      const dy = (CANVAS_H - dh) / 2;
      tempCanvas.image(bgImg, dx, dy, dw, dh);
    } else {
      if(bgColor !== null){
        tempCanvas.background(bgColor);
      } else {
        tempCanvas.clear();
      }
    }
    
    // Measure fields
    const measures = [];
    for(let i = 0; i < fields.length; i++){
      const f = fields[i];
      const preset = SIZE_PRESETS[f.size || 'M'];
      
      tempCanvas.textFont(fontTimes || 'Georgia');
      tempCanvas.textSize(preset.text);
      
      // Calculate width based on text content
      const txt = f.text || '';
      const textW = tempCanvas.textWidth(txt);
      const fieldW = Math.min(textW + preset.padX * 2, CONTENT_W);
      
      const maxW = CONTENT_W - preset.padX * 2;
      const lines = wrapTextForGraphics(tempCanvas, txt, maxW);
      const h = lines.length * preset.text * 1.2 + preset.padY * 2;
      
      measures.push({
        field: f,
        lines: lines,
        w: fieldW,
        h: h,
        r: preset.r,
        tsize: preset.text
      });
    }
    
    // Arrange fields into rows (horizontal layout with wrapping)
    const rows = [];
    let currentRow = [];
    let currentRowWidth = 0;
    const GAP = 0; // Gap between fields
    
    for(let i = 0; i < measures.length; i++){
      const item = measures[i];
      
      // Check if adding this item would exceed content width
      if(currentRowWidth + item.w > CONTENT_W && currentRow.length > 0){
        // Start new row
        rows.push(currentRow);
        currentRow = [item];
        currentRowWidth = item.w;
      } else {
        // Add to current row
        currentRow.push(item);
        currentRowWidth += item.w + (currentRow.length > 1 ? GAP : 0);
      }
    }
    
    // Add last row
    if(currentRow.length > 0){
      rows.push(currentRow);
    }
    
    // Calculate total height of all rows
    let totalH = 0;
    for(let i = 0; i < rows.length; i++){
      let rowHeight = 0;
      for(let j = 0; j < rows[i].length; j++){
        rowHeight = Math.max(rowHeight, rows[i][j].h);
      }
      totalH += rowHeight;
    }
    
    // Draw rows (with padding offset)
    let y = CANVAS_PADDING + (CONTENT_H - totalH) / 2;
    
    for(let i = 0; i < rows.length; i++){
      const row = rows[i];
      
      // Calculate row width for centering
      let rowWidth = 0;
      let rowHeight = 0;
      for(let j = 0; j < row.length; j++){
        rowWidth += row[j].w;
        rowHeight = Math.max(rowHeight, row[j].h);
        if(j > 0) rowWidth += GAP;
      }
      
      // Start x position (centered with padding)
      let x = CANVAS_PADDING + (CONTENT_W - rowWidth) / 2;
      
      // Draw each field in the row
      for(let j = 0; j < row.length; j++){
        const item = row[j];
        
        tempCanvas.noStroke();
        tempCanvas.fill(item.field.color || '#FFFFFF');
        tempCanvas.rect(x, y, item.w, item.h, Math.min(item.r, item.h/2));
        
        if(item.field.color === '#FFFFFF' || item.field.isDefault){
          tempCanvas.noStroke();
          tempCanvas.noFill();
          tempCanvas.rect(x, y, item.w, item.h, Math.min(item.r, item.h/2));
        }
        
        tempCanvas.noStroke();
        tempCanvas.fill(0);
        tempCanvas.textAlign(CENTER, CENTER);
        tempCanvas.textFont(fontTimes || 'Georgia');
        tempCanvas.textSize(item.tsize);
        
        const lineHeight = item.tsize * 1.2;
        const textBlockH = item.lines.length * lineHeight;
        const textY = y + (item.h - textBlockH) / 2 + lineHeight / 2 - item.tsize * 0.05;
        
        for(let k = 0; k < item.lines.length; k++){
          tempCanvas.text(item.lines[k], x + item.w / 2, textY + k * lineHeight);
        }
        
        x += item.w + GAP;
      }
      
      y += rowHeight;
    }
    
    const ts = new Date().toISOString().slice(0,10);
    const formatName = currentFormat;
    save(tempCanvas, `social-media-${formatName}-${ts}.png`);
  };
}

function wrapTextForGraphics(g, txt, maxWidth){
  if(!txt) return [''];
  
  const words = txt.split(' ');
  const lines = [];
  let currentLine = '';
  
  for(let i = 0; i < words.length; i++){
    const testLine = currentLine + (currentLine ? ' ' : '') + words[i];
    const testWidth = g.textWidth(testLine);
    
    if(testWidth > maxWidth && currentLine !== ''){
      lines.push(currentLine);
      currentLine = words[i];
    } else {
      currentLine = testLine;
    }
  }
  
  if(currentLine) lines.push(currentLine);
  
  return lines.length > 0 ? lines : [''];
}

function renderFieldRow(f){
  const container = document.getElementById('fields');
  const el = document.createElement('div');
  el.className = f.isDefault ? 'field default' : 'field';
  el.dataset.id = f.id;

  // Header
  const head = document.createElement('div');
  head.className = 'fieldHead';
  const title = document.createElement('strong');
  title.textContent = f.isDefault ? 'Default Field (White, Size L)' : 'Custom Field';
  head.appendChild(title);
  
  if(!f.isDefault){
    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn small';
    removeBtn.textContent = 'Remove';
    head.appendChild(removeBtn);
    removeBtn.onclick = () => removeField(f.id);
  }

  // Text input
  const row1 = document.createElement('div');
  row1.className = 'row';
  const lab1 = document.createElement('label');
  lab1.textContent = 'Text';
  const textInput = document.createElement('input');
  textInput.type = 'text';
  textInput.maxLength = 50;
  textInput.value = f.text || '';
  textInput.placeholder = 'Enter text (max 50)';
  row1.appendChild(lab1);
  row1.appendChild(textInput);
  textInput.oninput = (e) => updateField(f.id, 'text', e.target.value);

  el.appendChild(head);
  el.appendChild(row1);

  // Color and size for custom fields only
  if(!f.isDefault){
    const row2 = document.createElement('div');
    row2.className = 'row';
    
    const lab2 = document.createElement('label');
    lab2.textContent = 'Color';
    const colorSel = document.createElement('select');
    for(let i = 0; i < PALETTE.length; i++){
      const c = PALETTE[i];
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c.replace('#','');
      if(f.color === c) opt.selected = true;
      colorSel.appendChild(opt);
    }
    
    const lab3 = document.createElement('label');
    lab3.style.minWidth = '36px';
    lab3.style.textAlign = 'right';
    lab3.textContent = 'Size';
    const sizeSel = document.createElement('select');
    const sizes = ['S','M'];
    for(let i = 0; i < sizes.length; i++){
      const s = sizes[i];
      const o = document.createElement('option');
      o.value = s;
      o.textContent = s;
      if(f.size === s) o.selected = true;
      sizeSel.appendChild(o);
    }
    
    row2.appendChild(lab2);
    row2.appendChild(colorSel);
    row2.appendChild(lab3);
    row2.appendChild(sizeSel);
    el.appendChild(row2);
    
    colorSel.onchange = (e) => updateField(f.id, 'color', e.target.value);
    sizeSel.onchange = (e) => updateField(f.id, 'size', e.target.value);
  }

  container.appendChild(el);
}

function refreshFieldRows(){
  const container = document.getElementById('fields');
  container.innerHTML = '';
  for(let i = 0; i < fields.length; i++){
    renderFieldRow(fields[i]);
  }
}
</script>
</body>
</html>
